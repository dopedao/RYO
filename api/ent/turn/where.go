// Code generated by entc, DO NOT EDIT.

package turn

import (
	"time"

	"entgo.io/ent/dialect/sql"
	"github.com/dopedao/RYO/api/ent/predicate"
	"github.com/dopedao/RYO/api/ent/schema"
)

// ID filters vertices based on their ID field.
func ID(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id int) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// UserID applies equality check predicate on the "user_id" field. It's identical to UserIDEQ.
func UserID(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserID), v))
	})
}

// LocationID applies equality check predicate on the "location_id" field. It's identical to LocationIDEQ.
func LocationID(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocationID), v))
	})
}

// ItemID applies equality check predicate on the "item_id" field. It's identical to ItemIDEQ.
func ItemID(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldItemID), v))
	})
}

// BuyOrSell applies equality check predicate on the "buy_or_sell" field. It's identical to BuyOrSellEQ.
func BuyOrSell(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuyOrSell), v))
	})
}

// AmountToGive applies equality check predicate on the "amount_to_give" field. It's identical to AmountToGiveEQ.
func AmountToGive(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmountToGive), v))
	})
}

// TradeOccurs applies equality check predicate on the "trade_occurs" field. It's identical to TradeOccursEQ.
func TradeOccurs(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTradeOccurs), v))
	})
}

// UserPreTradeItem applies equality check predicate on the "user_pre_trade_item" field. It's identical to UserPreTradeItemEQ.
func UserPreTradeItem(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPostTradePreEventItem applies equality check predicate on the "user_post_trade_pre_event_item" field. It's identical to UserPostTradePreEventItemEQ.
func UserPostTradePreEventItem(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePostEventItem applies equality check predicate on the "user_post_trade_post_event_item" field. It's identical to UserPostTradePostEventItemEQ.
func UserPostTradePostEventItem(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPreTradeMoney applies equality check predicate on the "user_pre_trade_money" field. It's identical to UserPreTradeMoneyEQ.
func UserPreTradeMoney(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPostTradePreEventMoney applies equality check predicate on the "user_post_trade_pre_event_money" field. It's identical to UserPostTradePreEventMoneyEQ.
func UserPostTradePreEventMoney(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePostEventMoney applies equality check predicate on the "user_post_trade_post_event_money" field. It's identical to UserPostTradePostEventMoneyEQ.
func UserPostTradePostEventMoney(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// MarketPreTradeItem applies equality check predicate on the "market_pre_trade_item" field. It's identical to MarketPreTradeItemEQ.
func MarketPreTradeItem(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPostTradePreEventItem applies equality check predicate on the "market_post_trade_pre_event_item" field. It's identical to MarketPostTradePreEventItemEQ.
func MarketPostTradePreEventItem(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePostEventItem applies equality check predicate on the "market_post_trade_post_event_item" field. It's identical to MarketPostTradePostEventItemEQ.
func MarketPostTradePostEventItem(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPreTradeMoney applies equality check predicate on the "market_pre_tradeMoney" field. It's identical to MarketPreTradeMoneyEQ.
func MarketPreTradeMoney(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPostTradePreEventMoney applies equality check predicate on the "market_post_trade_pre_eventMoney" field. It's identical to MarketPostTradePreEventMoneyEQ.
func MarketPostTradePreEventMoney(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePostEventMoney applies equality check predicate on the "market_post_trade_post_eventMoney" field. It's identical to MarketPostTradePostEventMoneyEQ.
func MarketPostTradePostEventMoney(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// DealerDash applies equality check predicate on the "dealer_dash" field. It's identical to DealerDashEQ.
func DealerDash(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDealerDash), v))
	})
}

// WrangleDashedDealer applies equality check predicate on the "wrangle_dashed_dealer" field. It's identical to WrangleDashedDealerEQ.
func WrangleDashedDealer(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWrangleDashedDealer), v))
	})
}

// Mugging applies equality check predicate on the "mugging" field. It's identical to MuggingEQ.
func Mugging(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMugging), v))
	})
}

// RunFromMugging applies equality check predicate on the "run_from_mugging" field. It's identical to RunFromMuggingEQ.
func RunFromMugging(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRunFromMugging), v))
	})
}

// GangWar applies equality check predicate on the "gang_war" field. It's identical to GangWarEQ.
func GangWar(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGangWar), v))
	})
}

// DefendGangWar applies equality check predicate on the "defend_gang_war" field. It's identical to DefendGangWarEQ.
func DefendGangWar(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDefendGangWar), v))
	})
}

// CopRaid applies equality check predicate on the "cop_raid" field. It's identical to CopRaidEQ.
func CopRaid(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCopRaid), v))
	})
}

// BribeCops applies equality check predicate on the "bribe_cops" field. It's identical to BribeCopsEQ.
func BribeCops(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBribeCops), v))
	})
}

// FindItem applies equality check predicate on the "find_item" field. It's identical to FindItemEQ.
func FindItem(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFindItem), v))
	})
}

// LocalShipment applies equality check predicate on the "local_shipment" field. It's identical to LocalShipmentEQ.
func LocalShipment(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocalShipment), v))
	})
}

// WarehouseSeizure applies equality check predicate on the "warehouse_seizure" field. It's identical to WarehouseSeizureEQ.
func WarehouseSeizure(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWarehouseSeizure), v))
	})
}

// CreatedAt applies equality check predicate on the "created_at" field. It's identical to CreatedAtEQ.
func CreatedAt(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// UserIDEQ applies the EQ predicate on the "user_id" field.
func UserIDEQ(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserID), v))
	})
}

// UserIDNEQ applies the NEQ predicate on the "user_id" field.
func UserIDNEQ(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserID), v))
	})
}

// UserIDIn applies the In predicate on the "user_id" field.
func UserIDIn(vs ...string) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserID), v...))
	})
}

// UserIDNotIn applies the NotIn predicate on the "user_id" field.
func UserIDNotIn(vs ...string) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserID), v...))
	})
}

// UserIDGT applies the GT predicate on the "user_id" field.
func UserIDGT(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserID), v))
	})
}

// UserIDGTE applies the GTE predicate on the "user_id" field.
func UserIDGTE(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserID), v))
	})
}

// UserIDLT applies the LT predicate on the "user_id" field.
func UserIDLT(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserID), v))
	})
}

// UserIDLTE applies the LTE predicate on the "user_id" field.
func UserIDLTE(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserID), v))
	})
}

// UserIDContains applies the Contains predicate on the "user_id" field.
func UserIDContains(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldUserID), v))
	})
}

// UserIDHasPrefix applies the HasPrefix predicate on the "user_id" field.
func UserIDHasPrefix(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldUserID), v))
	})
}

// UserIDHasSuffix applies the HasSuffix predicate on the "user_id" field.
func UserIDHasSuffix(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldUserID), v))
	})
}

// UserIDEqualFold applies the EqualFold predicate on the "user_id" field.
func UserIDEqualFold(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldUserID), v))
	})
}

// UserIDContainsFold applies the ContainsFold predicate on the "user_id" field.
func UserIDContainsFold(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldUserID), v))
	})
}

// LocationIDEQ applies the EQ predicate on the "location_id" field.
func LocationIDEQ(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocationID), v))
	})
}

// LocationIDNEQ applies the NEQ predicate on the "location_id" field.
func LocationIDNEQ(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLocationID), v))
	})
}

// LocationIDIn applies the In predicate on the "location_id" field.
func LocationIDIn(vs ...string) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLocationID), v...))
	})
}

// LocationIDNotIn applies the NotIn predicate on the "location_id" field.
func LocationIDNotIn(vs ...string) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLocationID), v...))
	})
}

// LocationIDGT applies the GT predicate on the "location_id" field.
func LocationIDGT(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLocationID), v))
	})
}

// LocationIDGTE applies the GTE predicate on the "location_id" field.
func LocationIDGTE(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLocationID), v))
	})
}

// LocationIDLT applies the LT predicate on the "location_id" field.
func LocationIDLT(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLocationID), v))
	})
}

// LocationIDLTE applies the LTE predicate on the "location_id" field.
func LocationIDLTE(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLocationID), v))
	})
}

// LocationIDContains applies the Contains predicate on the "location_id" field.
func LocationIDContains(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLocationID), v))
	})
}

// LocationIDHasPrefix applies the HasPrefix predicate on the "location_id" field.
func LocationIDHasPrefix(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLocationID), v))
	})
}

// LocationIDHasSuffix applies the HasSuffix predicate on the "location_id" field.
func LocationIDHasSuffix(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLocationID), v))
	})
}

// LocationIDEqualFold applies the EqualFold predicate on the "location_id" field.
func LocationIDEqualFold(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLocationID), v))
	})
}

// LocationIDContainsFold applies the ContainsFold predicate on the "location_id" field.
func LocationIDContainsFold(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLocationID), v))
	})
}

// ItemIDEQ applies the EQ predicate on the "item_id" field.
func ItemIDEQ(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldItemID), v))
	})
}

// ItemIDNEQ applies the NEQ predicate on the "item_id" field.
func ItemIDNEQ(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldItemID), v))
	})
}

// ItemIDIn applies the In predicate on the "item_id" field.
func ItemIDIn(vs ...string) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldItemID), v...))
	})
}

// ItemIDNotIn applies the NotIn predicate on the "item_id" field.
func ItemIDNotIn(vs ...string) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldItemID), v...))
	})
}

// ItemIDGT applies the GT predicate on the "item_id" field.
func ItemIDGT(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldItemID), v))
	})
}

// ItemIDGTE applies the GTE predicate on the "item_id" field.
func ItemIDGTE(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldItemID), v))
	})
}

// ItemIDLT applies the LT predicate on the "item_id" field.
func ItemIDLT(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldItemID), v))
	})
}

// ItemIDLTE applies the LTE predicate on the "item_id" field.
func ItemIDLTE(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldItemID), v))
	})
}

// ItemIDContains applies the Contains predicate on the "item_id" field.
func ItemIDContains(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldItemID), v))
	})
}

// ItemIDHasPrefix applies the HasPrefix predicate on the "item_id" field.
func ItemIDHasPrefix(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldItemID), v))
	})
}

// ItemIDHasSuffix applies the HasSuffix predicate on the "item_id" field.
func ItemIDHasSuffix(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldItemID), v))
	})
}

// ItemIDEqualFold applies the EqualFold predicate on the "item_id" field.
func ItemIDEqualFold(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldItemID), v))
	})
}

// ItemIDContainsFold applies the ContainsFold predicate on the "item_id" field.
func ItemIDContainsFold(v string) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldItemID), v))
	})
}

// BuyOrSellEQ applies the EQ predicate on the "buy_or_sell" field.
func BuyOrSellEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBuyOrSell), v))
	})
}

// BuyOrSellNEQ applies the NEQ predicate on the "buy_or_sell" field.
func BuyOrSellNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBuyOrSell), v))
	})
}

// AmountToGiveEQ applies the EQ predicate on the "amount_to_give" field.
func AmountToGiveEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldAmountToGive), v))
	})
}

// AmountToGiveNEQ applies the NEQ predicate on the "amount_to_give" field.
func AmountToGiveNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldAmountToGive), v))
	})
}

// AmountToGiveIn applies the In predicate on the "amount_to_give" field.
func AmountToGiveIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldAmountToGive), v...))
	})
}

// AmountToGiveNotIn applies the NotIn predicate on the "amount_to_give" field.
func AmountToGiveNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldAmountToGive), v...))
	})
}

// AmountToGiveGT applies the GT predicate on the "amount_to_give" field.
func AmountToGiveGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldAmountToGive), v))
	})
}

// AmountToGiveGTE applies the GTE predicate on the "amount_to_give" field.
func AmountToGiveGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldAmountToGive), v))
	})
}

// AmountToGiveLT applies the LT predicate on the "amount_to_give" field.
func AmountToGiveLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldAmountToGive), v))
	})
}

// AmountToGiveLTE applies the LTE predicate on the "amount_to_give" field.
func AmountToGiveLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldAmountToGive), v))
	})
}

// TradeOccursEQ applies the EQ predicate on the "trade_occurs" field.
func TradeOccursEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldTradeOccurs), v))
	})
}

// TradeOccursNEQ applies the NEQ predicate on the "trade_occurs" field.
func TradeOccursNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldTradeOccurs), v))
	})
}

// UserPreTradeItemEQ applies the EQ predicate on the "user_pre_trade_item" field.
func UserPreTradeItemEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPreTradeItemNEQ applies the NEQ predicate on the "user_pre_trade_item" field.
func UserPreTradeItemNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPreTradeItemIn applies the In predicate on the "user_pre_trade_item" field.
func UserPreTradeItemIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserPreTradeItem), v...))
	})
}

// UserPreTradeItemNotIn applies the NotIn predicate on the "user_pre_trade_item" field.
func UserPreTradeItemNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserPreTradeItem), v...))
	})
}

// UserPreTradeItemGT applies the GT predicate on the "user_pre_trade_item" field.
func UserPreTradeItemGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPreTradeItemGTE applies the GTE predicate on the "user_pre_trade_item" field.
func UserPreTradeItemGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPreTradeItemLT applies the LT predicate on the "user_pre_trade_item" field.
func UserPreTradeItemLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPreTradeItemLTE applies the LTE predicate on the "user_pre_trade_item" field.
func UserPreTradeItemLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserPreTradeItem), v))
	})
}

// UserPostTradePreEventItemEQ applies the EQ predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePreEventItemNEQ applies the NEQ predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePreEventItemIn applies the In predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserPostTradePreEventItem), v...))
	})
}

// UserPostTradePreEventItemNotIn applies the NotIn predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserPostTradePreEventItem), v...))
	})
}

// UserPostTradePreEventItemGT applies the GT predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePreEventItemGTE applies the GTE predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePreEventItemLT applies the LT predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePreEventItemLTE applies the LTE predicate on the "user_post_trade_pre_event_item" field.
func UserPostTradePreEventItemLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserPostTradePreEventItem), v))
	})
}

// UserPostTradePostEventItemEQ applies the EQ predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPostTradePostEventItemNEQ applies the NEQ predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPostTradePostEventItemIn applies the In predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserPostTradePostEventItem), v...))
	})
}

// UserPostTradePostEventItemNotIn applies the NotIn predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserPostTradePostEventItem), v...))
	})
}

// UserPostTradePostEventItemGT applies the GT predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPostTradePostEventItemGTE applies the GTE predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPostTradePostEventItemLT applies the LT predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPostTradePostEventItemLTE applies the LTE predicate on the "user_post_trade_post_event_item" field.
func UserPostTradePostEventItemLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserPostTradePostEventItem), v))
	})
}

// UserPreTradeMoneyEQ applies the EQ predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPreTradeMoneyNEQ applies the NEQ predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPreTradeMoneyIn applies the In predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserPreTradeMoney), v...))
	})
}

// UserPreTradeMoneyNotIn applies the NotIn predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserPreTradeMoney), v...))
	})
}

// UserPreTradeMoneyGT applies the GT predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPreTradeMoneyGTE applies the GTE predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPreTradeMoneyLT applies the LT predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPreTradeMoneyLTE applies the LTE predicate on the "user_pre_trade_money" field.
func UserPreTradeMoneyLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserPreTradeMoney), v))
	})
}

// UserPostTradePreEventMoneyEQ applies the EQ predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePreEventMoneyNEQ applies the NEQ predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePreEventMoneyIn applies the In predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserPostTradePreEventMoney), v...))
	})
}

// UserPostTradePreEventMoneyNotIn applies the NotIn predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserPostTradePreEventMoney), v...))
	})
}

// UserPostTradePreEventMoneyGT applies the GT predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePreEventMoneyGTE applies the GTE predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePreEventMoneyLT applies the LT predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePreEventMoneyLTE applies the LTE predicate on the "user_post_trade_pre_event_money" field.
func UserPostTradePreEventMoneyLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserPostTradePreEventMoney), v))
	})
}

// UserPostTradePostEventMoneyEQ applies the EQ predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// UserPostTradePostEventMoneyNEQ applies the NEQ predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// UserPostTradePostEventMoneyIn applies the In predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldUserPostTradePostEventMoney), v...))
	})
}

// UserPostTradePostEventMoneyNotIn applies the NotIn predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldUserPostTradePostEventMoney), v...))
	})
}

// UserPostTradePostEventMoneyGT applies the GT predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// UserPostTradePostEventMoneyGTE applies the GTE predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// UserPostTradePostEventMoneyLT applies the LT predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// UserPostTradePostEventMoneyLTE applies the LTE predicate on the "user_post_trade_post_event_money" field.
func UserPostTradePostEventMoneyLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldUserPostTradePostEventMoney), v))
	})
}

// MarketPreTradeItemEQ applies the EQ predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPreTradeItemNEQ applies the NEQ predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPreTradeItemIn applies the In predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarketPreTradeItem), v...))
	})
}

// MarketPreTradeItemNotIn applies the NotIn predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarketPreTradeItem), v...))
	})
}

// MarketPreTradeItemGT applies the GT predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPreTradeItemGTE applies the GTE predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPreTradeItemLT applies the LT predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPreTradeItemLTE applies the LTE predicate on the "market_pre_trade_item" field.
func MarketPreTradeItemLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarketPreTradeItem), v))
	})
}

// MarketPostTradePreEventItemEQ applies the EQ predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePreEventItemNEQ applies the NEQ predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePreEventItemIn applies the In predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarketPostTradePreEventItem), v...))
	})
}

// MarketPostTradePreEventItemNotIn applies the NotIn predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarketPostTradePreEventItem), v...))
	})
}

// MarketPostTradePreEventItemGT applies the GT predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePreEventItemGTE applies the GTE predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePreEventItemLT applies the LT predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePreEventItemLTE applies the LTE predicate on the "market_post_trade_pre_event_item" field.
func MarketPostTradePreEventItemLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarketPostTradePreEventItem), v))
	})
}

// MarketPostTradePostEventItemEQ applies the EQ predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPostTradePostEventItemNEQ applies the NEQ predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPostTradePostEventItemIn applies the In predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarketPostTradePostEventItem), v...))
	})
}

// MarketPostTradePostEventItemNotIn applies the NotIn predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarketPostTradePostEventItem), v...))
	})
}

// MarketPostTradePostEventItemGT applies the GT predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPostTradePostEventItemGTE applies the GTE predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPostTradePostEventItemLT applies the LT predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPostTradePostEventItemLTE applies the LTE predicate on the "market_post_trade_post_event_item" field.
func MarketPostTradePostEventItemLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarketPostTradePostEventItem), v))
	})
}

// MarketPreTradeMoneyEQ applies the EQ predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPreTradeMoneyNEQ applies the NEQ predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPreTradeMoneyIn applies the In predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarketPreTradeMoney), v...))
	})
}

// MarketPreTradeMoneyNotIn applies the NotIn predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarketPreTradeMoney), v...))
	})
}

// MarketPreTradeMoneyGT applies the GT predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPreTradeMoneyGTE applies the GTE predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPreTradeMoneyLT applies the LT predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPreTradeMoneyLTE applies the LTE predicate on the "market_pre_tradeMoney" field.
func MarketPreTradeMoneyLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarketPreTradeMoney), v))
	})
}

// MarketPostTradePreEventMoneyEQ applies the EQ predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePreEventMoneyNEQ applies the NEQ predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePreEventMoneyIn applies the In predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarketPostTradePreEventMoney), v...))
	})
}

// MarketPostTradePreEventMoneyNotIn applies the NotIn predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarketPostTradePreEventMoney), v...))
	})
}

// MarketPostTradePreEventMoneyGT applies the GT predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePreEventMoneyGTE applies the GTE predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePreEventMoneyLT applies the LT predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePreEventMoneyLTE applies the LTE predicate on the "market_post_trade_pre_eventMoney" field.
func MarketPostTradePreEventMoneyLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarketPostTradePreEventMoney), v))
	})
}

// MarketPostTradePostEventMoneyEQ applies the EQ predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// MarketPostTradePostEventMoneyNEQ applies the NEQ predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyNEQ(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// MarketPostTradePostEventMoneyIn applies the In predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMarketPostTradePostEventMoney), v...))
	})
}

// MarketPostTradePostEventMoneyNotIn applies the NotIn predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyNotIn(vs ...schema.BigInt) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMarketPostTradePostEventMoney), v...))
	})
}

// MarketPostTradePostEventMoneyGT applies the GT predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyGT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// MarketPostTradePostEventMoneyGTE applies the GTE predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyGTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// MarketPostTradePostEventMoneyLT applies the LT predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyLT(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// MarketPostTradePostEventMoneyLTE applies the LTE predicate on the "market_post_trade_post_eventMoney" field.
func MarketPostTradePostEventMoneyLTE(v schema.BigInt) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMarketPostTradePostEventMoney), v))
	})
}

// DealerDashEQ applies the EQ predicate on the "dealer_dash" field.
func DealerDashEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDealerDash), v))
	})
}

// DealerDashNEQ applies the NEQ predicate on the "dealer_dash" field.
func DealerDashNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDealerDash), v))
	})
}

// WrangleDashedDealerEQ applies the EQ predicate on the "wrangle_dashed_dealer" field.
func WrangleDashedDealerEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWrangleDashedDealer), v))
	})
}

// WrangleDashedDealerNEQ applies the NEQ predicate on the "wrangle_dashed_dealer" field.
func WrangleDashedDealerNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWrangleDashedDealer), v))
	})
}

// MuggingEQ applies the EQ predicate on the "mugging" field.
func MuggingEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMugging), v))
	})
}

// MuggingNEQ applies the NEQ predicate on the "mugging" field.
func MuggingNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMugging), v))
	})
}

// RunFromMuggingEQ applies the EQ predicate on the "run_from_mugging" field.
func RunFromMuggingEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRunFromMugging), v))
	})
}

// RunFromMuggingNEQ applies the NEQ predicate on the "run_from_mugging" field.
func RunFromMuggingNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRunFromMugging), v))
	})
}

// GangWarEQ applies the EQ predicate on the "gang_war" field.
func GangWarEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGangWar), v))
	})
}

// GangWarNEQ applies the NEQ predicate on the "gang_war" field.
func GangWarNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGangWar), v))
	})
}

// DefendGangWarEQ applies the EQ predicate on the "defend_gang_war" field.
func DefendGangWarEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldDefendGangWar), v))
	})
}

// DefendGangWarNEQ applies the NEQ predicate on the "defend_gang_war" field.
func DefendGangWarNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldDefendGangWar), v))
	})
}

// CopRaidEQ applies the EQ predicate on the "cop_raid" field.
func CopRaidEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCopRaid), v))
	})
}

// CopRaidNEQ applies the NEQ predicate on the "cop_raid" field.
func CopRaidNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCopRaid), v))
	})
}

// BribeCopsEQ applies the EQ predicate on the "bribe_cops" field.
func BribeCopsEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBribeCops), v))
	})
}

// BribeCopsNEQ applies the NEQ predicate on the "bribe_cops" field.
func BribeCopsNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBribeCops), v))
	})
}

// FindItemEQ applies the EQ predicate on the "find_item" field.
func FindItemEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFindItem), v))
	})
}

// FindItemNEQ applies the NEQ predicate on the "find_item" field.
func FindItemNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFindItem), v))
	})
}

// LocalShipmentEQ applies the EQ predicate on the "local_shipment" field.
func LocalShipmentEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLocalShipment), v))
	})
}

// LocalShipmentNEQ applies the NEQ predicate on the "local_shipment" field.
func LocalShipmentNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLocalShipment), v))
	})
}

// WarehouseSeizureEQ applies the EQ predicate on the "warehouse_seizure" field.
func WarehouseSeizureEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldWarehouseSeizure), v))
	})
}

// WarehouseSeizureNEQ applies the NEQ predicate on the "warehouse_seizure" field.
func WarehouseSeizureNEQ(v bool) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldWarehouseSeizure), v))
	})
}

// CreatedAtEQ applies the EQ predicate on the "created_at" field.
func CreatedAtEQ(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtNEQ applies the NEQ predicate on the "created_at" field.
func CreatedAtNEQ(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtIn applies the In predicate on the "created_at" field.
func CreatedAtIn(vs ...time.Time) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtNotIn applies the NotIn predicate on the "created_at" field.
func CreatedAtNotIn(vs ...time.Time) predicate.Turn {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Turn(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldCreatedAt), v...))
	})
}

// CreatedAtGT applies the GT predicate on the "created_at" field.
func CreatedAtGT(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtGTE applies the GTE predicate on the "created_at" field.
func CreatedAtGTE(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLT applies the LT predicate on the "created_at" field.
func CreatedAtLT(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldCreatedAt), v))
	})
}

// CreatedAtLTE applies the LTE predicate on the "created_at" field.
func CreatedAtLTE(v time.Time) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldCreatedAt), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Turn) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Turn) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Turn) predicate.Turn {
	return predicate.Turn(func(s *sql.Selector) {
		p(s.Not())
	})
}
